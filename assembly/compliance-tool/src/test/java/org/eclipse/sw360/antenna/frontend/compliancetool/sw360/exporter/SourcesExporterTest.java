/*
 * Copyright (c) Bosch Software Innovations GmbH 2019.
 * Copyright (c) Bosch.IO GmbH 2020.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.antenna.frontend.compliancetool.sw360.exporter;

import nl.jqno.equalsverifier.EqualsVerifier;
import org.eclipse.sw360.antenna.sw360.client.adapter.SW360AttachmentUtils;
import org.eclipse.sw360.antenna.sw360.client.adapter.SW360ReleaseClientAdapterAsync;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.Self;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.attachments.SW360AttachmentType;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.attachments.SW360SparseAttachment;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.releases.SW360Release;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.releases.SW360ReleaseEmbedded;
import org.eclipse.sw360.antenna.sw360.client.utils.SW360ClientException;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.mockito.ArgumentCaptor;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.eclipse.sw360.antenna.sw360.client.utils.FutureUtils.failedFuture;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class SourcesExporterTest {
    /**
     * Default content of a test file generated by the test class.
     */
    private static final byte[] TEST_FILE_CONTENT = "This is a test file".getBytes(StandardCharsets.UTF_8);

    /**
     * Constant for the SHA-1 hash for the test files generated by this class.
     */
    private static final String TEST_FILE_SHA1 = "91b7b0b1e27bfbf7bc646946f35fa972c47c2d32";

    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    /**
     * The path where to store downloaded files.
     */
    private Path sourcePath;

    /**
     * Mock for the release client adapter.
     */
    private SW360ReleaseClientAdapterAsync releaseAdapter;

    /**
     * The exporter to be tested.
     */
    private SourcesExporter sourcesExporter;

    @Before
    public void setUp() throws IOException {
        sourcePath = folder.newFolder().toPath();
        releaseAdapter = mock(SW360ReleaseClientAdapterAsync.class);
        sourcesExporter = new SourcesExporter(sourcePath);
    }

    /**
     * Generates a number of source attachments for a test release.
     *
     * @param releaseIndex    the index of the test release
     * @param attachmentCount the number of attachments to generate
     * @return a set with the generated attachments
     */
    private static Set<SW360SparseAttachment> createAttachments(int releaseIndex, int attachmentCount) {
        Set<SW360SparseAttachment> attachments = new HashSet<>();
        for (int i = 0; i < attachmentCount; i++) {
            SW360SparseAttachment attachment = createAttachment(releaseIndex, i);
            attachments.add(attachment);
        }
        return attachments;
    }

    /**
     * Creates a test attachment from the given parameters.
     *
     * @param releaseIndex    the index of the test release
     * @param attachmentIndex the index of the test attachment
     * @return the test attachment
     */
    private static SW360SparseAttachment createAttachment(int releaseIndex, int attachmentIndex) {
        SW360SparseAttachment attachment = new SW360SparseAttachment();
        String attachmentId = "attach-" + (1000 * releaseIndex + attachmentIndex);
        attachment.getLinks().setSelf(new Self("https://sw360.org/attachments/" + attachmentId));
        attachment.setAttachmentType(SW360AttachmentType.SOURCE);
        attachment.setFilename("release" + releaseIndex + "_source" + attachmentIndex + ".jar");
        return attachment;
    }

    /**
     * Creates a test release that contains the given set of attachments.
     * attachments.
     *
     * @param releaseIndex the index of the test release
     * @param attachments  the set with attachments
     * @return the test release
     */
    private static SW360Release createReleaseWithAttachments(int releaseIndex, Set<SW360SparseAttachment> attachments) {
        SW360Release release = new SW360Release();
        release.setName("release" + releaseIndex);
        release.setVersion(releaseIndex + ".0");
        initAttachments(release, attachments);
        return release;
    }

    /**
     * Initializes the given release with the set of attachments specified.
     *
     * @param release     the release
     * @param attachments the attachments for this release
     */
    private static void initAttachments(SW360Release release, Set<SW360SparseAttachment> attachments) {
        SW360ReleaseEmbedded embedded = new SW360ReleaseEmbedded();
        release.setEmbedded(embedded);
        embedded.setAttachments(attachments);
    }

    /**
     * Generates the path for the given release. The attachments belonging to
     * this release are located under this path.
     *
     * @param release the release
     * @return the download path for this release
     */
    private Path releasePath(SW360Release release) {
        return sourcePath.resolve(release.getName()).resolve(release.getVersion());
    }

    /**
     * Generates the path for the given attachment of the given release.
     *
     * @param release    the release the attachment belongs to
     * @param attachment the attachment
     * @return the path where to download this attachment
     */
    private Path attachmentPath(SW360Release release, SW360SparseAttachment attachment) {
        return releasePath(release).resolve(attachment.getFilename());
    }

    /**
     * Creates a {@code ReleaseWithSources} object from the given data.
     *
     * @param release     the release
     * @param attachments the set with attachments
     * @return the resulting release with sources
     */
    private ReleaseWithSources createReleaseWithSources(SW360Release release,
                                                        Set<SW360SparseAttachment> attachments) {
        Set<Path> paths = attachments.stream()
                .map(attachment -> attachmentPath(release, attachment))
                .collect(Collectors.toSet());
        return new ReleaseWithSources(release, paths);
    }

    /**
     * Prepares the mock for release client to expect successful download
     * operations for the given set of attachments.
     *
     * @param release     the release affected
     * @param attachments the attachments to be downloaded
     */
    private void expectDownloads(SW360Release release, Set<SW360SparseAttachment> attachments) {
        attachments.forEach(attachment -> {
            Path path = attachmentPath(release, attachment);
            when(releaseAdapter.processAttachment(eq(release), eq(attachment.getAttachmentId()), any()))
                    .thenReturn(CompletableFuture.completedFuture(path));
        });
    }

    /**
     * Verifies that attachments have been downloaded using a correct processor
     * to the expected target directory.
     *
     * @param release     the release affected
     * @param attachments the attachments to be downloaded
     */
    private void verifyDownloads(SW360Release release, Set<SW360SparseAttachment> attachments) {
        final Path expPath = releasePath(release);
        attachments.forEach(attachment -> {
            ArgumentCaptor<SW360AttachmentUtils.AttachmentDownloadProcessorCreateDownloadFolderWithParents> captor =
                    ArgumentCaptor.forClass(SW360AttachmentUtils.AttachmentDownloadProcessorCreateDownloadFolderWithParents.class);
            verify(releaseAdapter).processAttachment(eq(release), eq(attachment.getAttachmentId()), captor.capture());
            SW360AttachmentUtils.AttachmentDownloadProcessorCreateDownloadFolderWithParents processor = captor.getValue();
            assertThat(processor.getFileName()).isEqualTo(attachment.getFilename());
            assertThat(processor.getDownloadPath()).isEqualTo(expPath);
            assertThat(processor.getCopyOptions()).containsOnly(StandardCopyOption.REPLACE_EXISTING);
        });
    }

    @Test
    public void testEqualsReleaseWithSources() {
        EqualsVerifier.forClass(ReleaseWithSources.class)
                .verify();
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testReleaseWithSourcesAttachmentsUnmodifiable() {
        Set<SW360SparseAttachment> attachments = createAttachments(3, 8);
        ReleaseWithSources releaseWithSources =
                createReleaseWithSources(createReleaseWithAttachments(3, attachments), attachments);

        releaseWithSources.getSourceAttachmentPaths().clear();
    }

    @Test
    public void testAttachmentsAreDownloadedSuccessfully() {
        Set<SW360SparseAttachment> attachments1 = createAttachments(1, 1);
        Set<SW360SparseAttachment> attachments2 = createAttachments(2, 2);
        SW360Release release1 = createReleaseWithAttachments(1, attachments1);
        SW360Release release2 = createReleaseWithAttachments(2, attachments2);
        List<SW360Release> releases = Arrays.asList(release1, release2);
        List<ReleaseWithSources> expResult =
                Arrays.asList(createReleaseWithSources(release1, attachments1),
                        createReleaseWithSources(release2, attachments2));
        expectDownloads(release1, attachments1);
        expectDownloads(release2, attachments2);

        Collection<ReleaseWithSources> result =
                sourcesExporter.downloadSources(releaseAdapter, releases);
        assertThat(result).containsExactlyInAnyOrderElementsOf(expResult);
        verifyDownloads(release1, attachments1);
        verifyDownloads(release2, attachments2);
    }

    @Test
    public void testOnlySourceAttachmentsAreDownloaded() {
        Set<SW360SparseAttachment> sourceAttachments = createAttachments(1, 4);
        SW360SparseAttachment otherAttachment = createAttachment(1, 42);
        otherAttachment.setAttachmentType(SW360AttachmentType.SCREENSHOT);
        Set<SW360SparseAttachment> attachments = new HashSet<>(sourceAttachments);
        attachments.add(otherAttachment);
        SW360Release release = createReleaseWithAttachments(1, attachments);
        ReleaseWithSources releaseWithSources = createReleaseWithSources(release, sourceAttachments);
        expectDownloads(release, sourceAttachments);

        Collection<ReleaseWithSources> result =
                sourcesExporter.downloadSources(releaseAdapter, Collections.singleton(release));
        assertThat(result).containsOnly(releaseWithSources);
        verifyDownloads(release, sourceAttachments);
    }

    @Test
    public void testExceptionsDuringAttachmentDownloadAreHandled() {
        Set<SW360SparseAttachment> sourceAttachments = createAttachments(1, 2);
        SW360SparseAttachment failedAttachment = createAttachment(1, 42);
        Set<SW360SparseAttachment> attachments = new HashSet<>(sourceAttachments);
        attachments.add(failedAttachment);
        SW360Release release = createReleaseWithAttachments(1, attachments);
        ReleaseWithSources releaseWithSources = createReleaseWithSources(release, sourceAttachments);
        expectDownloads(release, sourceAttachments);
        when(releaseAdapter.processAttachment(eq(release), eq(failedAttachment.getAttachmentId()), any()))
                .thenReturn(failedFuture(new IOException("Download failed")));

        Collection<ReleaseWithSources> result =
                sourcesExporter.downloadSources(releaseAdapter, Collections.singleton(release));
        assertThat(result).containsOnly(releaseWithSources);
    }

    @Test
    public void testPathsAreSanitizedForDownload() {
        SW360Release release = new SW360Release();
        release.setName("a \"complex\" *release*/name?! -with >0 #special.characters+");
        release.setVersion("10%");
        SW360SparseAttachment attachment = createAttachment(1, 2);
        attachment.setFilename("strange/file\\.txt");
        Set<SW360SparseAttachment> sourceAttachments = Collections.singleton(attachment);
        initAttachments(release, sourceAttachments);
        expectDownloads(release, sourceAttachments);

        Collection<ReleaseWithSources> result =
                sourcesExporter.downloadSources(releaseAdapter, Collections.singleton(release));
        assertThat(result).hasSize(1);
        ArgumentCaptor<SW360AttachmentUtils.AttachmentDownloadProcessorCreateDownloadFolderWithParents> captor =
                ArgumentCaptor.forClass(SW360AttachmentUtils.AttachmentDownloadProcessorCreateDownloadFolderWithParents.class);
        verify(releaseAdapter).processAttachment(eq(release), eq(attachment.getAttachmentId()), captor.capture());
        SW360AttachmentUtils.AttachmentDownloadProcessorCreateDownloadFolderWithParents processor = captor.getValue();
        Path expPath = sourcePath.resolve("a__complex___release__name___-with__0__special.characters_").resolve("10_");
        assertThat(processor.getDownloadPath()).isEqualTo(expPath);
        assertThat(processor.getFileName()).isEqualTo("strange_file_.txt");
    }

    /**
     * Creates a test file at the given location with the content specified.
     *
     * @param path    the path of the test file
     * @param content the content to be written into the test file
     * @return the path to the test file that was created
     */
    private static Path createTestFile(Path path, byte[] content) {
        try {
            Files.createDirectories(path.getParent());
            return Files.write(path, content);
        } catch (IOException e) {
            throw new AssertionError("Could not create test file " + path, e);
        }
    }

    /**
     * Creates a test file at the given location with default content.
     *
     * @param path the path of the test file
     * @return the path to the file that was created
     */
    private static Path createTestFile(Path path) {
        return createTestFile(path, TEST_FILE_CONTENT);
    }

    /**
     * Creates files for all the attachments of the given release.
     *
     * @param releaseWithSources the release
     */
    private static void createAttachmentFiles(ReleaseWithSources releaseWithSources) {
        releaseWithSources.getSourceAttachmentPaths()
                .forEach(SourcesExporterTest::createTestFile);
    }

    /**
     * Checks that the given file exists.
     *
     * @param path the path to be checked
     * @return a flag whether this file exists
     */
    private static boolean checkFileExists(Path path) {
        return Files.exists(path);
    }

    /**
     * Checks that all the attachment files referenced by the given release
     * exist on the local disk.
     *
     * @param release the release to be checked
     */
    private static void checkAllAttachmentsExist(ReleaseWithSources release) {
        assertThat(release.getSourceAttachmentPaths().stream().allMatch(SourcesExporterTest::checkFileExists))
                .isTrue();
    }

    @Test
    public void testUnreferencedFilesCanBeRemoved() {
        Set<SW360SparseAttachment> attachments1 = createAttachments(1, 2);
        Set<SW360SparseAttachment> attachments2 = createAttachments(2, 3);
        Set<SW360SparseAttachment> attachments3 = createAttachments(1, 3);
        ReleaseWithSources release1 =
                createReleaseWithSources(createReleaseWithAttachments(1, attachments1), attachments1);
        ReleaseWithSources release2 =
                createReleaseWithSources(createReleaseWithAttachments(2, attachments2), attachments2);
        SW360SparseAttachment unreferencedAttachment = createAttachment(17, 47);
        SW360Release unreferencedRelease1 =
                createReleaseWithAttachments(17, Collections.singleton(unreferencedAttachment));
        SW360Release unreferencedRelease2 = createReleaseWithAttachments(1, attachments3);
        unreferencedRelease2.setVersion("2.0");
        ReleaseWithSources unreferencedRelease2WithSources =
                createReleaseWithSources(unreferencedRelease2, attachments3);
        Path unreferencedPath = attachmentPath(unreferencedRelease1, unreferencedAttachment);
        createTestFile(unreferencedPath);
        createAttachmentFiles(release1);
        createAttachmentFiles(release2);
        createAttachmentFiles(unreferencedRelease2WithSources);
        Path furtherSubPath1 = createTestFile(releasePath(release1.getRelease())
                .resolve("sub").resolve("subFile.txt")).getParent();
        Path furtherSubPath2 = createTestFile(releasePath(release1.getRelease())
                .resolve("aSubDir").resolve("otherSubFile.txt")).getParent();
        Path topPath1 = createTestFile(sourcePath.resolve("a.txt"));
        Path topPath2 = createTestFile(sourcePath.resolve("z.txt"));

        sourcesExporter.removeUnreferencedFiles(Arrays.asList(release1, release2));
        checkAllAttachmentsExist(release1);
        checkAllAttachmentsExist(release2);
        assertThat(checkFileExists(unreferencedPath)).isFalse();
        assertThat(checkFileExists(releasePath(unreferencedRelease1))).isFalse();
        assertThat(checkFileExists(releasePath(unreferencedRelease2))).isFalse();
        assertThat(checkFileExists(furtherSubPath1)).isFalse();
        assertThat(checkFileExists(furtherSubPath2)).isFalse();
        assertThat(checkFileExists(topPath1)).isFalse();
        assertThat(checkFileExists(topPath2)).isFalse();
    }

    @Test
    public void testPathsAreSanitizedWhenRemovingUnreferencedFiles() {
        SW360Release release = new SW360Release();
        release.setName("org.apache.commons/commons-lang3");
        release.setVersion("3.*");
        Path delPath1 = sourcePath.resolve("org.apache.commons");
        Path delPath2 = delPath1.resolve("commons-lang3");
        Path delPath3 = createTestFile(delPath2.resolve("lang-source.zip"));
        Path validPath1 = sourcePath.resolve("org.apache.commons_commons-lang3").resolve("3._");
        Path validPath2 = createTestFile(validPath1.resolve("lang-source.zip"));
        Set<SW360SparseAttachment> attachments = createAttachments(1, 1);
        initAttachments(release, attachments);
        ReleaseWithSources releaseWithSources = createReleaseWithSources(release, attachments);

        sourcesExporter.removeUnreferencedFiles(Collections.singleton(releaseWithSources));
        assertThat(checkFileExists(validPath1)).isTrue();
        assertThat(checkFileExists(validPath2)).isTrue();
        assertThat(checkFileExists(delPath3)).isFalse();
        assertThat(checkFileExists(delPath2)).isFalse();
        assertThat(checkFileExists(delPath1)).isFalse();
    }

    @Test
    public void testIOExceptionIsHandledWhenRemovingUnreferencedFiles() {
        Path nonExisting = sourcePath.resolve("non/existing/sub/folder");
        sourcesExporter = new SourcesExporter(nonExisting);

        sourcesExporter.removeUnreferencedFiles(Collections.emptyList());
    }

    @Test
    public void testNoDownloadIfIdenticalFileExists() {
        SW360SparseAttachment attachment = createAttachment(1, 1);
        attachment.setSha1(TEST_FILE_SHA1);
        SW360Release release = createReleaseWithAttachments(1, Collections.singleton(attachment));
        ReleaseWithSources releaseWithSources =
                createReleaseWithSources(release, Collections.singleton(attachment));
        createTestFile(attachmentPath(release, attachment));

        Collection<ReleaseWithSources> result =
                sourcesExporter.downloadSources(releaseAdapter, Collections.singleton(release));
        assertThat(result).containsOnly(releaseWithSources);
    }

    @Test
    public void testDownloadIfHashIsDifferent() {
        SW360SparseAttachment attachment = createAttachment(1, 1);
        attachment.setSha1(TEST_FILE_SHA1);
        Set<SW360SparseAttachment> attachments = Collections.singleton(attachment);
        SW360Release release = createReleaseWithAttachments(1, attachments);
        ReleaseWithSources releaseWithSources =
                createReleaseWithSources(release, attachments);
        createTestFile(attachmentPath(release, attachment),
                "other content".getBytes(StandardCharsets.UTF_8));
        expectDownloads(release, attachments);

        Collection<ReleaseWithSources> result =
                sourcesExporter.downloadSources(releaseAdapter, Collections.singleton(release));
        assertThat(result).containsOnly(releaseWithSources);
        verify(releaseAdapter).processAttachment(eq(release), eq(attachment.getAttachmentId()), any());
    }

    @Test
    public void testDownloadIfHashCalculationFails() {
        SW360SparseAttachment attachment = createAttachment(1, 1);
        attachment.setSha1(TEST_FILE_SHA1);
        Set<SW360SparseAttachment> attachments = Collections.singleton(attachment);
        SW360Release release = createReleaseWithAttachments(1, attachments);
        ReleaseWithSources releaseWithSources =
                createReleaseWithSources(release, attachments);
        createTestFile(sourcePath.resolve(attachment.getFilename()));
        expectDownloads(release, attachments);
        sourcesExporter = new SourcesExporter(sourcePath) {
            @Override
            String calculateLocalAttachmentHash(Path localPath) {
                throw new SW360ClientException("Hash failure");
            }
        };

        Collection<ReleaseWithSources> result =
                sourcesExporter.downloadSources(releaseAdapter, Collections.singleton(release));
        assertThat(result).containsOnly(releaseWithSources);
        verify(releaseAdapter).processAttachment(eq(release), eq(attachment.getAttachmentId()),
                any(SW360AttachmentUtils.AttachmentDownloadProcessorCreateDownloadFolderWithParents.class));
    }
}
