/*
 * Copyright (c) Bosch.IO GmbH 2020.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.antenna.sw360;

import org.eclipse.sw360.antenna.model.license.License;
import org.eclipse.sw360.antenna.sw360.client.adapter.AttachmentUploadRequest;
import org.eclipse.sw360.antenna.sw360.client.adapter.AttachmentUploadResult;
import org.eclipse.sw360.antenna.sw360.client.adapter.SW360Connection;
import org.eclipse.sw360.antenna.sw360.client.adapter.SW360LicenseClientAdapter;
import org.eclipse.sw360.antenna.sw360.client.adapter.SW360ProjectClientAdapter;
import org.eclipse.sw360.antenna.sw360.client.adapter.SW360ReleaseClientAdapter;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.SW360Visibility;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.Self;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.attachments.SW360AttachmentType;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.attachments.SW360SparseAttachment;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.licenses.SW360License;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.licenses.SW360SparseLicense;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.projects.SW360Project;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.projects.SW360ProjectType;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.releases.SW360Release;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.releases.SW360ReleaseEmbedded;
import org.eclipse.sw360.antenna.sw360.client.rest.resource.releases.SW360SparseRelease;
import org.eclipse.sw360.antenna.sw360.client.utils.SW360ClientException;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.mockito.ArgumentCaptor;
import org.mockito.stubbing.Answer;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyCollection;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

public class SW360MetaDataUpdaterTest {
    /**
     * Default content of a test file generated by the test class.
     */
    private static final String TEST_FILE_CONTENT = "This is a test file";

    /**
     * Constant for the SHA-1 hash for the test files generated by this class.
     */
    private static final String TEST_FILE_SHA1 = "91b7b0b1e27bfbf7bc646946f35fa972c47c2d32";

    /**
     * Default name for test releases.
     */
    private static final String RELEASE_NAME = "testRelease";

    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    private SW360MetaDataUpdater metaDataUpdater;
    private final SW360Connection connection = mock(SW360Connection.class);
    private final SW360ProjectClientAdapter projectClientAdapter = mock(SW360ProjectClientAdapter.class);
    private final SW360LicenseClientAdapter licenseClientAdapter = mock(SW360LicenseClientAdapter.class);
    private final SW360ReleaseClientAdapter releaseClientAdapter = mock(SW360ReleaseClientAdapter.class);

    @Before
    public void setUp() {
        when(connection.getReleaseAdapter())
                .thenReturn(releaseClientAdapter);
        when(connection.getProjectAdapter())
                .thenReturn(projectClientAdapter);
        when(connection.getLicenseAdapter())
                .thenReturn(licenseClientAdapter);

        metaDataUpdater = new SW360MetaDataUpdater(connection);
    }

    /**
     * Creates a test file with the given content at the location specified.
     *
     * @param path    the path where to create the test file
     * @param content the content of the test file
     * @return the path to the test file
     * @throws IOException if an error occurs
     */
    private static Path createTestFile(Path path, String content) throws IOException {
        return Files.write(path, content.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Creates a test release.
     *
     * @param name the name of the test release
     * @return the test release
     */
    private static SW360Release createRelease(String name) {
        SW360Release release = new SW360Release();
        release.setName(name);
        release.setEmbedded(new SW360ReleaseEmbedded());
        return release;
    }

    /**
     * Adds a source attachment with the given file name to a release.
     *
     * @param release            the target release
     * @param attachmentFileName the attachment file name
     * @return the updated release
     */
    private static SW360Release addSourceAttachment(SW360Release release, String attachmentFileName) {
        SW360SparseAttachment attachment = createAttachment(attachmentFileName, SW360AttachmentType.SOURCE);
        return addAttachment(release, attachment);
    }

    /**
     * Adds the given attachment to a release.
     *
     * @param release    the target release
     * @param attachment the attachment to be added
     * @return the updated release
     */
    private static SW360Release addAttachment(SW360Release release, SW360SparseAttachment attachment) {
        Set<SW360SparseAttachment> existingAttachments = release.getEmbedded().getAttachments();
        Set<SW360SparseAttachment> newAttachments = new HashSet<>(existingAttachments);
        newAttachments.add(attachment);
        release.getEmbedded().setAttachments(newAttachments);
        return release;
    }

    /**
     * Creates an attachment with the given properties.
     *
     * @param attachmentFileName the attachment file name
     * @param type               the type of the attachment
     * @return the new attachment
     */
    private static SW360SparseAttachment createAttachment(String attachmentFileName, SW360AttachmentType type) {
        SW360SparseAttachment attachment = new SW360SparseAttachment();
        attachment.setFilename(attachmentFileName);
        attachment.setAttachmentType(type);
        attachment.setSha1(TEST_FILE_SHA1);
        attachment.getLinks().setSelf(new Self("https://attachments.org/" + System.identityHashCode(attachment)));
        return attachment;
    }

    /**
     * Returns a path to an attachment in the temporary folder.
     *
     * @param name the name of the attachment file
     * @return the path to this attachment
     */
    private Path attachmentPath(String name) {
        return folder.getRoot().toPath().resolve(name);
    }

    /**
     * Creates a test license with the given name.
     *
     * @param name the license name
     * @return the test license with this name
     */
    private static SW360SparseLicense createLicense(String name) {
        SW360SparseLicense license = new SW360SparseLicense();
        return license.setShortName(name)
                .setFullName(name + "_full");
    }

    /**
     * Generates a list with test licenses.
     *
     * @return the list with test licenses
     */
    private static List<SW360SparseLicense> createTestLicenses() {
        return IntStream.range(1, 9)
                .mapToObj(idx -> "testLicense" + idx)
                .map(SW360MetaDataUpdaterTest::createLicense)
                .collect(Collectors.toList());
    }

    @Test
    public void testGetLicensesWithExistingLicense() {
        final String licenseName = "licenseName";
        List<SW360SparseLicense> testLicenses = createTestLicenses();
        testLicenses.add(createLicense(licenseName));
        final SW360License license = new SW360License()
                .setShortName(licenseName);
        License licenseAntenna = new License();
        licenseAntenna.setId(licenseName);
        when(licenseClientAdapter.getLicenses()).thenReturn(testLicenses);
        when(licenseClientAdapter.getLicenseByName(licenseName))
                .thenReturn(Optional.of(license));

        final Set<SW360License> licenses = metaDataUpdater.getLicenses(Collections.singletonList(licenseAntenna));

        assertThat(licenses).hasSize(1);

        verify(licenseClientAdapter, times(1)).getLicenses();
        verify(licenseClientAdapter, times(1)).getLicenseByName(licenseName);
    }

    @Test
    public void testGetLicensesWithNonExistingLicense() {
        final String licenseName = "licenseName";
        final SW360License license = new SW360License()
                .setShortName(licenseName);
        License licenseAntenna = new License();
        licenseAntenna.setId(licenseName);
        when(licenseClientAdapter.getLicenses())
                .thenReturn(createTestLicenses());
        when(licenseClientAdapter.getLicenseByName(licenseName))
                .thenReturn(Optional.of(license));

        final Set<SW360License> licenses = metaDataUpdater.getLicenses(Collections.singletonList(licenseAntenna));

        assertThat(licenses).hasSize(0);
        verify(licenseClientAdapter, times(1)).getLicenses();
    }

    @Test
    public void testGetOrCreateRelease() {
        final SW360Release release = new SW360Release();
        release.setName("test-component");
        release.setVersion("0.1-alpha");
        final SW360Release newRelease = new SW360Release();
        when(releaseClientAdapter.getSparseReleaseByExternalIds(any())).thenReturn(Optional.empty());
        when(releaseClientAdapter.getSparseReleaseByNameAndVersion(release.getName(), release.getVersion()))
                .thenReturn(Optional.empty());
        when(releaseClientAdapter.createRelease(release)).thenReturn(newRelease);

        assertThat(metaDataUpdater.getOrCreateRelease(release, true, false)).isEqualTo(newRelease);
        verify(releaseClientAdapter, never()).updateRelease(any());
    }

    @Test
    public void testGetOrCreateReleaseFoundByExternalIDsWithSW360Precedence() {
        SW360SparseRelease sparseRelease = new SW360SparseRelease();
        SW360Release foundRelease = new SW360Release();
        SW360Release queryRelease = new SW360Release();
        SW360Release patchedRelease = new SW360Release();
        Map<String, String> extIDs = Collections.singletonMap("foo", "bar");
        final String copyright = "(C) Test copyright";
        queryRelease.setExternalIds(extIDs);
        foundRelease.setCopyrights(copyright);
        when(releaseClientAdapter.getSparseReleaseByExternalIds(extIDs)).thenReturn(Optional.of(sparseRelease));
        when(releaseClientAdapter.enrichSparseRelease(sparseRelease)).thenReturn(Optional.of(foundRelease));
        when(releaseClientAdapter.updateRelease(any()))
                .thenAnswer((Answer<SW360Release>) invocationOnMock -> {
                    SW360Release rel = invocationOnMock.getArgument(0);
                    assertThat(rel.getExternalIds()).isEqualTo(extIDs);
                    assertThat(rel.getCopyrights()).isEqualTo(copyright);
                    return patchedRelease;
                });

        assertThat(metaDataUpdater.getOrCreateRelease(queryRelease, true, false)).isEqualTo(patchedRelease);
    }



    @Test
    public void testGetOrCreateReleaseFoundByExternalIDsWithArtifactPrecedence() {
        SW360SparseRelease sparseRelease = new SW360SparseRelease();
        SW360Release foundRelease = new SW360Release();
        SW360Release queryRelease = new SW360Release();
        SW360Release patchedRelease = new SW360Release();
        Map<String, String> extIDs = Collections.singletonMap("foo", "bar");
        final String queryCopyright = "(C) Test copyright query";
        final String foundCopyright = "(C) Test copyright found";
        queryRelease.setExternalIds(extIDs);
        queryRelease.setCopyrights(queryCopyright);
        foundRelease.setCopyrights(foundCopyright);
        when(releaseClientAdapter.getSparseReleaseByExternalIds(extIDs)).thenReturn(Optional.of(sparseRelease));
        when(releaseClientAdapter.enrichSparseRelease(sparseRelease)).thenReturn(Optional.of(foundRelease));
        when(releaseClientAdapter.updateRelease(any()))
                .thenAnswer((Answer<SW360Release>) invocationOnMock -> {
                    SW360Release rel = invocationOnMock.getArgument(0);
                    assertThat(rel.getExternalIds()).isEqualTo(extIDs);
                    assertThat(rel.getCopyrights()).isEqualTo(queryCopyright);
                    return patchedRelease;
                });

        assertThat(metaDataUpdater.getOrCreateRelease(queryRelease, true, true)).isEqualTo(patchedRelease);
    }

    @Test
    public void testGetOrCreateReleaseFoundByNameAndVersion() {
        SW360SparseRelease sparseRelease = new SW360SparseRelease();
        SW360Release foundRelease = new SW360Release();
        SW360Release queryRelease = new SW360Release();
        queryRelease.setExternalIds(Collections.singletonMap("id", "42"));
        foundRelease.setExternalIds(Collections.singletonMap("id2", "47"));
        queryRelease.setName("theComponent");
        queryRelease.setVersion("100.0");
        when(releaseClientAdapter.getSparseReleaseByExternalIds(queryRelease.getExternalIds())).thenReturn(Optional.empty());
        when(releaseClientAdapter.getSparseReleaseByNameAndVersion(queryRelease.getName(), queryRelease.getVersion()))
                .thenReturn(Optional.of(sparseRelease));
        when(releaseClientAdapter.enrichSparseRelease(sparseRelease)).thenReturn(Optional.of(foundRelease));

        assertThat(metaDataUpdater.getOrCreateRelease(queryRelease, false, false)).isEqualTo(queryRelease);
        assertThat(queryRelease.getExternalIds()).containsKey("id2");
        verify(releaseClientAdapter, never()).updateRelease(any());
    }

    @Test
    public void testCreateProjectWithProjectPresent() {
        final String projectName = "projectName";
        final String projectVersion = "projectVersion";
        final String projectId = "12345";
        SW360Project project = new SW360Project();
        project.getLinks().setSelf(new Self("https://sw360.org/projects/" + projectId));
        when(projectClientAdapter.getProjectByNameAndVersion(projectName, projectVersion))
                .thenReturn(Optional.of(project));

        metaDataUpdater.createProject(projectName, projectVersion, Collections.emptySet());

        verify(projectClientAdapter, never()).createProject(any());
        verify(projectClientAdapter, times(1)).addSW360ReleasesToSW360Project(projectId, Collections.emptySet());
    }

    @Test
    public void testCreateProjectWithProjectNotPresent() {
        final String projectName = "projectName";
        final String projectVersion = "projectVersion";
        final String projectId = "12345";
        final SW360Project newProject = new SW360Project();
        newProject.setName(projectName);
        newProject.setVersion(projectVersion);
        newProject.getLinks().setSelf(new Self("http://some.link/" + projectId));
        when(projectClientAdapter.getProjectByNameAndVersion(projectName, projectVersion))
                .thenReturn(Optional.empty());
        when(projectClientAdapter.createProject(any()))
                .thenReturn(newProject);

        metaDataUpdater.createProject(projectName, projectVersion, Collections.emptySet());

        ArgumentCaptor<SW360Project> captor = ArgumentCaptor.forClass(SW360Project.class);
        verify(projectClientAdapter, times(1)).createProject(captor.capture());
        verify(projectClientAdapter, times(1)).addSW360ReleasesToSW360Project(projectId, Collections.emptySet());
        SW360Project sampleProject = captor.getValue();
        assertThat(sampleProject.getName()).isEqualTo(projectName);
        assertThat(sampleProject.getVersion()).isEqualTo(projectVersion);
        assertThat(sampleProject.getDescription()).isEqualTo(projectName + " " + projectVersion);
        assertThat(sampleProject.getProjectType()).isEqualTo(SW360ProjectType.PRODUCT);
        assertThat(sampleProject.getVisibility()).isEqualTo(SW360Visibility.BUISNESSUNIT_AND_MODERATORS);
    }

    @Test
    public void testUploadAttachments() throws IOException {
        SW360Release release = createRelease(RELEASE_NAME);
        Path uploadPath = createTestFile(attachmentPath("upload.doc"), TEST_FILE_CONTENT);
        SW360AttachmentType attachmentType = SW360AttachmentType.SOURCE;
        Map<Path, SW360AttachmentType> attachments = Collections.singletonMap(uploadPath, attachmentType);
        AttachmentUploadRequest<SW360Release> expRequest = AttachmentUploadRequest.builder(release)
                .addAttachment(uploadPath, attachmentType)
                .build();
        AttachmentUploadResult<SW360Release> expResult = new AttachmentUploadResult<>(createRelease("update"));
        when(releaseClientAdapter.uploadAttachments(expRequest))
                .thenReturn(expResult);

        AttachmentUploadResult<SW360Release> uploadResult =
                metaDataUpdater.uploadAttachments(release, attachments, false);

        assertThat(uploadResult).isEqualTo(expResult);
        verify(releaseClientAdapter).uploadAttachments(expRequest);
        verifyNoMoreInteractions(releaseClientAdapter);
    }

    @Test
    public void testUploadAttachmentsSkipUploads() throws IOException {
        Path uploadPath = createTestFile(attachmentPath("upload.doc"), TEST_FILE_CONTENT);
        SW360AttachmentType attachmentType = SW360AttachmentType.SOURCE;
        SW360SparseAttachment attachment = createAttachment(uploadPath.getFileName().toString(), attachmentType);
        SW360Release release = addAttachment(createRelease(RELEASE_NAME), attachment);
        Map<Path, SW360AttachmentType> attachments = Collections.singletonMap(uploadPath, attachmentType);

        AttachmentUploadResult<SW360Release> uploadResult =
                metaDataUpdater.uploadAttachments(release, attachments, false);
        assertThat(uploadResult).isEqualTo(new AttachmentUploadResult<>(release));
    }

    @Test
    public void testUploadAttachmentsConflictNoForce() throws IOException {
        Path uploadPath = createTestFile(attachmentPath("upload.doc"), TEST_FILE_CONTENT + "_changed");
        SW360AttachmentType attachmentType = SW360AttachmentType.SOURCE;
        SW360SparseAttachment attachment = createAttachment(uploadPath.getFileName().toString(), attachmentType);
        SW360Release release = addAttachment(createRelease(RELEASE_NAME), attachment);
        Map<Path, SW360AttachmentType> attachments = Collections.singletonMap(uploadPath, attachmentType);

        AttachmentUploadResult<SW360Release> uploadResult =
                metaDataUpdater.uploadAttachments(release, attachments, false);
        assertThat(uploadResult.getTarget()).isEqualTo(release);
        assertThat(uploadResult.successfulUploads()).isEmpty();
        AttachmentUploadRequest.Item expFailedItem = new AttachmentUploadRequest.Item(uploadPath, attachmentType);
        assertThat(uploadResult.failedUploads().keySet())
                .containsOnly(expFailedItem);
        Throwable throwable = uploadResult.failedUploads().get(expFailedItem);
        assertThat(throwable).isInstanceOf(IllegalStateException.class);
        assertThat(throwable.getMessage()).contains(uploadPath.toString());
    }

    @Test
    public void testUploadAttachmentsConflictForce() throws IOException {
        Path uploadPath1 = createTestFile(attachmentPath("upload.doc"), TEST_FILE_CONTENT + "_other");
        Path uploadPath2 = createTestFile(attachmentPath("sources.zip"), "many-source-files");
        SW360AttachmentType attachmentType = SW360AttachmentType.SOURCE;
        Map<Path, SW360AttachmentType> attachments = new HashMap<>();
        attachments.put(uploadPath1, attachmentType);
        attachments.put(uploadPath2, attachmentType);
        SW360SparseAttachment attachment1 = createAttachment(uploadPath1.getFileName().toString(), attachmentType);
        SW360SparseAttachment attachment2 = createAttachment(uploadPath2.getFileName().toString(), attachmentType);
        SW360Release release = addAttachment(addAttachment(createRelease(RELEASE_NAME), attachment1), attachment2);
        AttachmentUploadResult<SW360Release> expResult = new AttachmentUploadResult<>(createRelease("update"));
        when(releaseClientAdapter.uploadAttachments(any())).thenReturn(expResult);

        AttachmentUploadResult<SW360Release> uploadResult =
                metaDataUpdater.uploadAttachments(release, attachments, true);

        assertThat(uploadResult).isEqualTo(expResult);
        @SuppressWarnings("unchecked")
        ArgumentCaptor<AttachmentUploadRequest<SW360Release>> captor =
                ArgumentCaptor.forClass(AttachmentUploadRequest.class);
        verify(releaseClientAdapter).uploadAttachments(captor.capture());
        assertThat(captor.getValue().getItems())
                .containsOnly(new AttachmentUploadRequest.Item(uploadPath1, attachmentType),
                        new AttachmentUploadRequest.Item(uploadPath2, attachmentType));
        verify(releaseClientAdapter).deleteAttachments(release,
                new HashSet<>(Arrays.asList(attachment1.getId(), attachment2.getId())));
    }

    @Test
    public void testUploadAttachmentsConflictFailuresAreAddedToResult() throws IOException {
        Path uploadPath1 = createTestFile(attachmentPath("conflict.doc"), TEST_FILE_CONTENT + "_other");
        Path uploadPath2 = createTestFile(attachmentPath("sources.zip"), TEST_FILE_CONTENT);
        SW360AttachmentType attachmentType = SW360AttachmentType.SOURCE;
        Map<Path, SW360AttachmentType> attachments = new HashMap<>();
        attachments.put(uploadPath1, attachmentType);
        attachments.put(uploadPath2, attachmentType);
        SW360SparseAttachment attachment = createAttachment(uploadPath1.getFileName().toString(), attachmentType);
        SW360Release release = addAttachment(createRelease(RELEASE_NAME), attachment);
        AttachmentUploadRequest<SW360Release> expRequest = AttachmentUploadRequest.builder(release)
                .addAttachment(uploadPath2, attachmentType)
                .build();
        AttachmentUploadResult<SW360Release> expResult = new AttachmentUploadResult<>(createRelease("update"));
        when(releaseClientAdapter.uploadAttachments(expRequest))
                .thenReturn(expResult);

        AttachmentUploadResult<SW360Release> uploadResult =
                metaDataUpdater.uploadAttachments(release, attachments, false);
        assertThat(uploadResult.failedUploads().keySet())
                .containsOnly(new AttachmentUploadRequest.Item(uploadPath1, attachmentType));
    }

    @Test
    public void testExceptionsDuringAttachmentDeleteAreHandled() throws IOException {
        final String attachmentFileName = "unDeletableAttachment.doc";
        SW360Release release = addSourceAttachment(createRelease(RELEASE_NAME), attachmentFileName);
        Path uploadPath = createTestFile(attachmentPath(attachmentFileName), TEST_FILE_CONTENT + "_modified");
        Map<Path, SW360AttachmentType> attachments = Collections.singletonMap(uploadPath, SW360AttachmentType.SOURCE);
        AttachmentUploadRequest<SW360Release> expRequest = AttachmentUploadRequest.builder(release)
                .addAttachment(uploadPath, SW360AttachmentType.SOURCE)
                .build();
        when(releaseClientAdapter.uploadAttachments(expRequest))
                .thenReturn(new AttachmentUploadResult<>(release));
        when(releaseClientAdapter.deleteAttachments(any(), anyCollection()))
                .thenThrow(new SW360ClientException("Delete rejected"));

        metaDataUpdater.uploadAttachments(release, attachments, true);
        verify(releaseClientAdapter).uploadAttachments(expRequest);
    }

    @Test
    public void testExceptionsWhenCalculatingAttachmentHashAreHandled() throws IOException {
        final String attachmentFileName = "failingHashAttachmentFileName.doc";
        SW360Release release = addSourceAttachment(createRelease(RELEASE_NAME), attachmentFileName);
        Path uploadPath = createTestFile(attachmentPath(attachmentFileName), TEST_FILE_CONTENT);
        Map<Path, SW360AttachmentType> attachments = Collections.singletonMap(uploadPath, SW360AttachmentType.SOURCE);
        AttachmentUploadRequest<SW360Release> expRequest = AttachmentUploadRequest.builder(release)
                .addAttachment(uploadPath, SW360AttachmentType.SOURCE)
                .build();
        when(releaseClientAdapter.uploadAttachments(expRequest))
                .thenReturn(new AttachmentUploadResult<>(release));
        metaDataUpdater = new SW360MetaDataUpdater(connection) {
            @Override
            String calculateAttachmentHash(Path path) {
                throw new SW360ClientException("Hash failed");
            }
        };

        metaDataUpdater.uploadAttachments(release, attachments, true);
        verify(releaseClientAdapter).uploadAttachments(expRequest);
    }

    @Test
    public void testDeleteSourceAttachments() {
        SW360SparseAttachment attachment1 = createAttachment("source1", SW360AttachmentType.SOURCE);
        SW360SparseAttachment attachment2 = createAttachment("source2", SW360AttachmentType.SOURCE);
        SW360SparseAttachment attachment3 = createAttachment("other1", SW360AttachmentType.BINARY);
        SW360SparseAttachment attachment4 = createAttachment("other1", SW360AttachmentType.DOCUMENT);
        SW360Release release = addAttachment(addAttachment(addAttachment(addAttachment(createRelease(RELEASE_NAME),
                attachment1), attachment2), attachment3), attachment4);
        SW360Release updatedRelease = addAttachment(addAttachment(createRelease(RELEASE_NAME), attachment3), attachment4);
        when(releaseClientAdapter.deleteAttachments(release,
                new HashSet<>(Arrays.asList(attachment1.getId(), attachment2.getId()))))
                .thenReturn(updatedRelease);

        SW360Release result = metaDataUpdater.deleteSourceAttachments(release);
        assertThat(result).isEqualTo(updatedRelease);
    }

    @Test
    public void testDeleteSourceAttachmentsNothingToDelete() {
        SW360Release release = createRelease(RELEASE_NAME);

        assertThat(metaDataUpdater.deleteSourceAttachments(release)).isEqualTo(release);
        verifyZeroInteractions(releaseClientAdapter);
    }

    @Test
    public void testDeleteSpecificAttachment() {
        SW360SparseAttachment attachment1 = createAttachment("source1", SW360AttachmentType.SOURCE);
        SW360SparseAttachment attachment2 = createAttachment("source2", SW360AttachmentType.SOURCE);
        SW360Release release = addAttachment(addAttachment(createRelease(RELEASE_NAME), attachment1), attachment2);
        SW360Release updatedRelease = addAttachment(createRelease(RELEASE_NAME), attachment2);
        when(releaseClientAdapter.deleteAttachments(release, Collections.singleton(attachment1.getId())))
                .thenReturn(updatedRelease);

        SW360Release result = metaDataUpdater.deleteAttachments(release,
                attachment -> attachment1.getFilename().equals(attachment.getFilename()));
        assertThat(result).isEqualTo(updatedRelease);
    }
}
